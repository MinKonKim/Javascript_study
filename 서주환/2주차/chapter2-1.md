Chapter_2

## 실행 컨텍스트
### : 실행 코드에 제공할 환경 정보들을 모아놓은 객체

#### JS 동적 언어로서의 성격을 가장 잘 파악 할 수 있는 개념
js는 실행 컨텍스트가 활성화되는 시점에 호이스팅, 환경정보 구성, this값을 설정 -> 특이한 현상들 발생

---

#### > stack(스택): 출입구가 하나 뿐인 깊은 우물같은 구조
    ex) abcd 입력 -> dcba 아웃 (반대로 꺼낸다)

- 스택이 넘칠 때 에러를 뱉어낸다!

#### > queue(큐): 양쪽이 모두 열려있는 파이프 구조
    ex) abcd 입력 -> abcd 아웃 (순서대로 꺼낸다)

동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들 모아 컨텍스트 구성, 콜 스택 쌓아 올린다.

---

* 동일한 환경 = 하나의 실행 컨텍스트 구성

    - 전역공간, eval()함수, 함수 등이 있다.

- 한 실행 컨텍스트가 콜 스택의 맨 위로 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점이다.

-> 실행 컨택스트가 활성화 될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장.

이 객체는 자바스크립트 엔진이 활용할 목적으로 생성할 뿐 개발자 코드를 통해선 확인할 수 없다. 

---

### > VariableEnvironment
#### : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보.

실행 컨텍스트를 생성할 때, 정보를 먼저 담은 다음, 이를 그대로 복사해서 LexicalEnvironment를 만들고, 이후에 LexicalEnvironment를 주로 활용!

### > LexicalEnvironment
#### : 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영.
#### : 사전적인

### > environmentRecord와 호이스팅

#### environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다.

- 구성하는 함수에 지정된 매개변수 식별자, 선언한 함수가 있을 경우, 그 함수 자체, var로 선언된 변수의 식별자 등이 식별자에 해당 <br/>
- 컨텍스트 내부 전체를 처음부터 끝까지 훑으며 순서대로 수집

#### 전역 실행 컨텍스트는 변수 객체를 생성하는 대신 자바스크립트 구동 환경이 별도로 제공하는 (전역)객체를 활용. window, Node.js의 글로벌 객체가 있다
이들은 호스트 객체로 분류된다

- 내장 객체 - 내장 객체는 JavaScript 언어 자체에 내장되어 있는 객체 
ex) Array, String, Math... <br/>
- 호스트 객체 - JavaScript 코드가 실행되는 환경에 의해 제공되는 객체


### > 호이스팅 : 변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념 // 실제로 끌어올리진 않는다.

### 호이스팅 규칙

#### 변수 호이스팅 
: var 호이스팅이 발생, 선언과 초기화가 거의 동시에 이뤄진다.
변수에 대한 메모리가 살아있기에 선언부 위치와 상관없이 참조,할당이 가능 <br/><br/>
: let, const는 호이스팅이 발생하면, 선언만 이루어지고 실행 시점에서 실질적인 선언부를 만날 때까지 초기화는 이뤄지지 않는다.
변수에 대한 메모리가 존재하지 않기에 선언부 상단에서 참조, 할당이 불가능하다. 이 간극을 `TDZ`라고 부르며 때문에 호이스팅이 일어나지 않는 것처럼 동작

#### 함수 호이스팅
: 다른 무엇보다 가장 먼저 이뤄진다. 게다가 선언,초기화, 할당 단계를 동시에 진행하기에  TDZ도 존재하지 않고 상단에서 참조, 호출 가능

---

### 함수 선언문과 함수 표현식

둘 다 함수를 새롭게 정의할 때 쓰는 방식

- #### 함수 선언문:

1. function 정의부만 존재하고 별도의 할당 명령이 없는 것을 의미
2. 함수명이 정의되어 있어야 한다

<br/>

- #### 함수 표현식: 정의한 function을 별도의 변수에 할당하는 것을 의미

일반적으로 함수 표현식은 익명 함수 표현식을 말한다.

```
function a () {} // 함수 선언문 a는 변수명
a() //함수 실행

const b = function () {}
b()

var c = function d () {} 
//기명 함수 표현식. 변수명은 c, 함수명은 d

c() //실행
d() //에러
```
<br/><br/>
c함수 내부에서는 c()로 호출하던 d()로 호출하던 잘 실행된다.
함수 내부에서 재귀함수를 호출하는 용도로 함수명을 쓸 수 있다.<br/>
다만 c()로 호출해도 되는 상황에서 굳이 d()로 호출해야 할 필요가 있을지 의문이다.

기명 함수 표현식에서 주의할 점
 외부에서는 함수명으로 함수를 호출할 수 없다..<br/> 즉 내부에서만 접근 가능.<br/>
 모든 브라우저들이 익명 함수 표현식의 변수명을 함수의 name프로퍼티에 할당하고 있다.

 1. 함수 선언문은 전체를 호이스팅<br/>
 2. 함수 표현식은 변수 선언부만 호이스팅<br/>
 3. 함수를 다른 변수에 값으로써 '할당'한 것이 곧 함수 표현식

전역 컨텍스트가 활성화될 때 전역공간에 선언된 함수들이 모두 가장 위로 끌어올려진다.
동일한 변수명에 서로 다른 값을 할당할 경우 나중에 할당한 값이 먼저 할당한 값을 덮어씌운다.<br/>
즉, 코드를 실행하는 중에 실제로 호출되는 함수는 마지막에 선언된 함수뿐이다.


