# Chapter__1

<br /> <br />


# 1. 데이터 타입

- ## 데이터 타입의 종류

 ### 1) 기본형(primitive)

: num, string, boolean, null, undefined 등

 ### 2) 참조형(reference)

: object, array, function, date 등

<br />

#### 기본형과 참조형의 구분
-> 참조형은 말 그대로 참조가 되고 기본형은 할당이나 연산 시, 복제가 된다.
- 기본값은 값이 담긴 주소값을 바로 복제
- 참조형은 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제

<br />

불변성?

# 2. 메모리와 데이터

: 하나의 메모리 조각 = 비트(bit)
각 비트는 고유한 식별자를 통해 위치 확인

`1바이트 = 8비트`
= `1바이트는 0,1 두 값을 가지므로 2^8=256개의 값을 표현할 수 있다.`


- 과거 정적 타입의 언어(C, C++, java)는 메모리의 낭비를 최소화하기 위해 데이터 타입별로 할당할 메모리 영역을 나누어 정해놨었다.

- 그러나 용량이 과거보다 월등히 커진 상태에서 나온 js는 메모리 관리에 대한 압박에서 자유로워졌다.(타입별 구분 x)

=> 모든 데이터는 바이트 단위의 식별자, 즉 `메모리 주소값`을 통해 서로 구분,연결 할 수 있다.

<br />

# 3. 식별자와 변수

- 식별자: 어떠한 데이터를 식별할 때 사용하는 이름: 변수명
- 변수: '변할 수 있는 수' = 변할 수 있는 무언가(데이터)
  ex) 숫자, 문자열, 객체, 배열 등등 모두 데이터이다.

<br />

  # 4. 데이터 할당

  - 변수 선언과 할당

메모리를 더욱 효율적으로 관리하기 위해
변환한 데이터를 다시 저장하기 위해서는 '확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업'이 선행

효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적이다. 

-> 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아진다!!

예) 문자열 abc의 마지막에 dfe를 추가하라고 하면 기존의 저장된 공간에 추가해 할당하는 대신에 abcdfe라는 문자열을 새로 만들어 별도의 공간에 저장하고 그 주소를 변수 공간에 연결


-> 기존 문자열에 어떤 변환을 가하든 상관 없이 무조건 새로 만들어 별도의 공간에 저장한다!!

<!-- ## 기본형 데이터와 참조형 데이터  -->
<br />

# 5. 불변값
:변수와 상수를 구분하는 성질은 '변경 가능성'

- 바꿀 수 있으면 변수
- 바꿀 수 없으면 상수

- 불변값과 상수의 개념을 오해하기 쉽다. 명확하게 구분 할 필요성이 있다.

- 변수와 상수를 구분 짓는 변경 가능성의 대상은 `변수 영역` 메모리
- 한 번 데이터 할당이 이루어진 변수 공간에 다른 데이터를 재할당 할 수 있는지 여부가 관건.

- 불변성 여부를 구분할 때의 변경 가능성의 대상은 `데이터 영역` 메모리

- 기본형 데이터인 숫자, 문자열, boolean, null, undefined, symbol은 모두 불변값.

- 문자열 값도 한 번 만든 값을ㄹ 바꿀 수 없고, 숫자 값도 다른 값으로 변경할 수 없다.

- 변경은 새로 만드는 동작을 통해서만 이뤄진다.-> 불변값의 성질

- 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다.

<br />

# 6. 가변값

기본형 데이터는 모두 불변값이라고 한다. 
기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고, 불변값을 활용하는 방안도 있다.

기본형 데이터와의 차이는 '객체의 변수(property) 영역이 별도로 존재
데이터 영역에 저장된 값은 모두 불변값이다.

참조형 데이터는 불변하지 않다

참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우를 중첩 객체(nested) 라고 한다.


###  변수 복사 비교

변수를 복사하는 과정은 기본,참조형 데이터 모두 같은 주소를 바라보게 된다.
다만 데이터 할당 과정에서는 차이가 있다.

-> 어떤 데이터 타입이든 변수에 할당하기 위해 주소값을 복사해야 하기 때문에 js의 모든 데이터 타입은 참조형 데이터이다

참조형 데이터에서의 가변값은 데이터 자체를 변경하는 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다.

## 얕은 복사 , 깊은 복사

- ### 얕은 복사: 바로 아래 단계의 값만 복사
: 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 시, 주소값만 복사
사본 또는 원본을 바꾸면 원본 또는 사본도 바뀐다.

- ### 깊은 복사: 내부의 모든 값들을 하나씩 찾아 모두 복사

: 완전히 새로운 데이터를 만들려고 할 때, 객체 프로퍼티 중 값이  기본형 데이터일 경우 그대로 복사, 참조형 데이터일 경우 내부의 프로퍼티들을 다시 복사

: 객체를 JSON 문법으로 표현된 문자열로 전환, 다시 JSON 객체로 바꾼다.

## undefined /  null

"JS에서의 없음 

undefined 
: 사용자가 명시적으로 지정할 수 도 있지만 값이 존재하지 않을 때 자동으로 부여된다.

1) 값을 대입하지 않은 변수, 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근 할 때
```
var a
console.log(a)
```
2) 객체 내부의 존재하지 않는 프로퍼티에 접근 할 때
```
let a = 1
console.log(b)
```
3) return문이 없거나 호출되지 않는 함수 실행 결과 일 때
```
let func = function() {}
const f = func()
console.log(f)
```

`비어있는 요소`와 `undefined를 할당한 요소`는 출력 결과가 다르다
`비어있는 요소` 순회와 관련된 메서드들의 순회 대상에서 제외된다.

- 존재하지 않는 프로퍼티에 대해서 순회할 수 없는 것이 어쩌면 당연한 부분이다.
즉, 아직까진 존재하지 않는 프로퍼티로 인식하고 있는 것이다

- 사용자가 명시적으로 지정한 undefined는 자체로 값이된다.
고유의 키값이 실존, 그러므로 하나의 값으로 동작하기에 순회의 대상이 될 수 있다.

- 존재하지 않는 상태의 undefined는 말 그대로 값이 없기에 순회의 대상이 될 수 없는 것이다.

- 비어있는 요소를 명시적으로 나타낼 때는 null을 사용하면 된다.

- null의 주의점: typeof null => object (js버그)

- 어떤 변수 값이 null인지 판별하기 위해선 동등 연산자(==)를 써야 null인지 undefined인지 판별할 수 있다

# 
