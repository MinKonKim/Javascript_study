##this

자바스크립트에서의 this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정된다.
실행 컨텍스트는 함수를 호출할 떄 생성되므로,<h5>this는 함수를 호출할 때 결정된다</h5>

##전역 공간에서의 this
전역 공간에서의 this는 전역 객체를 가르킨다.
브라우저 환경에서 전역객체는window이고 Node.js 환경에서는 giobal이다.

<h4>자바스크립트의 모든 변수는 실은 특정객체의 프로퍼티로서 작동한다.</h4>
<h5>정확히 표현하면 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다.</h5>

##메서드로서 호출할 떄 그 메서드 내부에서의 this

함수vs메서드

이 둘을 구분하는 차이는 독립성에 있다.
함수- 그 자체로 독립적인 기능을 수행
메서드- 자신을 호출한 대상 객체에 관한 동작을 수행

점 표기법이든 대괄호 표기법이든, 어떤 함수를 호출할 때 그 함수이름 앞에 객체가 명시돼 있는 경우에는 메서드로 호출한것이고 그렇지 않은 모든 경우에는 함수로 호출한 것입니다.

##메서드 내부에서의 this
this에는 호출한 주체에 대한 정보가 담긴다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명 앞의 객체이다. 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 this이다.

##함수로서 호출할 때 그 함수 내부에서의 this
-함수 내부에서의 this
어떤 함수를 함수로서 호출할 경우 this는 지정되지 않는다. this는 호출한 주체에 대한 정보가 담긴다.
따라서 함수에서의 this는 전역 객체를 가르킨다.

-메서드의 내부함수에서의 this
this 바인딩에 관해서는 함수를 실행하는 당시의 주변환경은 중요하지 않고, 오직 해당 함수를 호출하는 수문 앞에 점 또는 대괄호 표기가 있는지 없는지가 관건.

##메서드의 내부 함수에서의 this를 우회하는 방법
호출 주체가 없을 때는 자동으로 전역객체를 바인딩하지않고 호출 당시 주변 환경의 this를 그대로 상속받아 사용할 수 있다면 좋을거같다.
그 방법은

var obj = {
    outer: function() {}
    console.log(this);
    var innerFunc1 = function () {
    console.log(this);
    };
    innerFunc();

    var self = this;
    var innerFunc2 = function () {
    console.log(self);
    }
}  
obj.outer();

변수를 활용하면 된다.

##this를 바인딩하지 않는 함수
es6부터는 this가 전역객체를 바라보는 문제를 보완하고자 this를 바인딩하지 않는 화살표 함수를 도입했다.
화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용한다. 
그러므로 화살표 함수를 사용하면 우회법이 불필요하다.

##콜백 함수 호출 시 그 함수 내부에서의 this
콜백 함수의 제어권을 가지는 함수가 콜백 함수에서의 this를 무엇으로 할지를 결정하며,특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라봅니다.

###명시적으로 this를 바인딩하는 방법

##call 메서드
메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령
call메서드의 첫 번쨰 인자를 this로 바인딩하고, 이후의 인자들을 호출할 함수의 매개변수로 하면 임의의 객체를 this로 지정가능

##apply 메서드
call 메서드와 기능적으로 완전히 동일
차이는 두 번쨰 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점에서만 차이가 있다.

##유사배열객체에 배열 메서드를 적용
객체에는 배열 메서드를 직접 적용할 수 없다. 그러나 키가 0 또는 양의 정수인 프로퍼티가 존재하고 length 프로퍼티의 값이 0또는 양의 정수인 객체, 즉 배열의 구조와 유사한 객체의 경우(유사배열객체)는 call또는apply 메서드를 이용해 배열 메서드를 차용할 수 있다.

##생성자 내부에서 다른 생성자를 호출

생성자 내부에 다른 생성자와 공통된 내용이 있을 경우 call또는apply를 이용해 다른 생성자를 호출하면 간단하게 반복을 줄일 수 있다.

##여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 - apply 활용
여러개의 인수를 받는 메서드에게 하나의 배열로 인수들을 전달하고 싶을 떄 apply 메서드를 사용하면 좋다.
하지만 es6의 스프레드 연산자를 이용하면 apply를 적용하는 것보다 더욱 간편하다.

##bind 메서드
-call과 비슷하지만 즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환한다.
-함수에 this를 미리 적용하는 것과 부분 적용 함수를 구현하는 두 가지 목적을 모두 지닌다.

##name 프로퍼티
bind 메서드를 적용해서 새로 만든 함수는 한 가지 독특한 성질이 있다.
name프로퍼티의 동사 bind의 수동태인 bound라는 접두어가 붙는다.

##상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기
-메서드의 내부함수에서 메서드의 this를 그대로 바라보게 하려면 self등으로 우회했는데 call,apply,bind 메서드를 이용하면 더 깔끔하게 우회할 수 있다.
또한 콜백 함수를 인자로 받는 함수나 메서드 중에서 기본적으로 콜백 함수 내에서의 this에 관려하는 함수 또는 메서드에 대해서도 bind 메서드를 이용하면 this의 값을 바꿀 수 있다.

##화살표 함수의 예외사항
화살표 함수는 실행 컨텍스트 생성 시 this를 바인딩하는 과정이 제외되었다.
즉 이 함수 내부에는 this가 없으며 접근하고자 하면 스코프체인상 가장 가까운 this에 접근하게 된다.

##별도의 인자로 this를 받는 경우 (콜백 함수 내에서의 this)
콜백 함수를 인자로 받는 메서드 중 일부는 추가로 this로 지정할 객체를 지정할 수 있는 경우가 있다.
이러한 메서드의 객체값을 지정하면 콜백 함수 내부에서 this값을 원하는 대로 변경 가능하다.
이런 형태는 여러 내부 요소에 대한 같은 동작을 반복 수행해야 하는 배열 메서드에 많이 포진되 있다.
대표적인 배열 메서드는 forEach다.


##정리##
-명시적 this 바인딩이 없는 경우
전역공간에서의 this는 전역객체를 참조한다.
어떤 함수를 메서드로서 호출한 경우 this는 메서드 호출 주체(메서드명 앞의 객체)를 참조한다.
어떤 함수를 함수로서 호출한 경우 this는 전역객체를 참조한다.
콜백 함수 내부에서의 this는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바에 따르며,정의하지 않은 경우 전역객체를 참조한다.
생성자 함수에서의 this는 생성될 인스턴스를 참조한다.

-명시적 this 바인딩
ccall,apply 메서드는 this를 명시적으로 지정하면서 함수 또는 메서드를 호출
bind 메서드는 this 및 함수에 넘길 인수를 일부 지정해서 새로운 함수를 만든다.
요소를 순회하면서 콜백 함수를 반복 호출하는 내용의 일부 메서드는 별도의 인자로 this를 받기도 함.

