##this

자바스크립트에서의 this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정된다.
실행 컨텍스트는 함수를 호출할 떄 생성되므로,<h5>this는 함수를 호출할 때 결정된다</h5>

##전역 공간에서의 this
전역 공간에서의 this는 전역 객체를 가르킨다.
브라우저 환경에서 전역객체는window이고 Node.js 환경에서는 giobal이다.

<h4>자바스크립트의 모든 변수는 실은 특정객체의 프로퍼티로서 작동한다.</h4>
<h5>정확히 표현하면 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다.</h5>

##메서드로서 호출할 떄 그 메서드 내부에서의 this

함수vs메서드

이 둘을 구분하는 차이는 독립성에 있다.
함수- 그 자체로 독립적인 기능을 수행
메서드- 자신을 호출한 대상 객체에 관한 동작을 수행

점 표기법이든 대괄호 표기법이든, 어떤 함수를 호출할 때 그 함수이름 앞에 객체가 명시돼 있는 경우에는 메서드로 호출한것이고 그렇지 않은 모든 경우에는 함수로 호출한 것입니다.

##메서드 내부에서의 this
this에는 호출한 주체에 대한 정보가 담긴다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명 앞의 객체이다. 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 this이다.

##함수로서 호출할 때 그 함수 내부에서의 this
-함수 내부에서의 this
어떤 함수를 함수로서 호출할 경우 this는 지정되지 않는다. this는 호출한 주체에 대한 정보가 담긴다.
따라서 함수에서의 this는 전역 객체를 가르킨다.

-메서드의 내부함수에서의 this
this 바인딩에 관해서는 함수를 실행하는 당시의 주변환경은 중요하지 않고, 오직 해당 함수를 호출하는 수문 앞에 점 또는 대괄호 표기가 있는지 없는지가 관건.

##메서드의 내부 함수에서의 this를 우회하는 방법
호출 주체가 없을 때는 자동으로 전역객체를 바인딩하지않고 호출 당시 주변 환경의 this를 그대로 상속받아 사용할 수 있다면 좋을거같다.
그 방법은

var obj = {
    outer: function() {}
    console.log(this);
    var innerFunc1 = function () {
    console.log(this);
    };
    innerFunc();

    var self = this;
    var innerFunc2 = function () {
    console.log(self);
    }
}  
obj.outer();

변수를 활용하면 된.



