## 1. 데이터 타입의 종류

JavaScript에서는 데이터 타입을 크게 두 가지로 나눌 수 있습니다: **기본형(Primitive Types)**과 **참조형(Reference Types)**입니다.

### 1-1. 기본형 (Primitive Types)

기본형 데이터 타입은 다음과 같습니다:

-   **number** , **string** , **boolean** , **null** , **undefined** , **symbol**

기본형 데이터들은 **불변성**을 가지고 있습니다. 즉, 기본형 데이터는 직접 수정할 수 없고, 새 값을 만들어내는 방식으로 동작합니다. (주솟값)

### 1-2. 참조형 (Reference Types)

참조형 데이터 타입은 다음과 같습니다:

-   **object** , **array** , **function** , **date** , **regexp** , **Map** , **WeakMap** **Set** , **WeakSet**

참조형 데이터는 **가변성**을 가지고 있습니다. 즉, 참조형 데이터는 변경할 수 있으며, 여러 변수들이 동일한 데이터 위치를 참조할 수 있습니다.

## 2. 데이터 타입에 관한 배경지식

### 2-1. 메모리와 데이터

#### 비트와 바이트

**첫 번째로, 비트와 바이트에 대해 알아볼까요?**

-   **비트 (Bit)**는 데이터의 가장 작은 조각입니다. 비트는 0 아니면 1 두 가지 값만 가질 수 있습니다.

-   **바이트 (Byte)**는 8개의 비트를 모은 것입니다. 그래서 1바이트는 256개의 서로 다른 값을 표현할 수 있습니다.

**왜 바이트 단위로 데이터를 다루는 게 좋을까요?**:

-   **비트**를 하나하나 다루는 것은 매우 복잡하고 느릴 수 있습니다.
-   **바이트** 단위로 묶으면 데이터 처리와 저장이 훨씬 더 간단하고 빠릅니다. 마치 여러 개의 작은 상자를 하나의 큰 상자로 바꾸면, 물건을 정리하고 찾는 게 더 쉬운 것과 비슷합니다.

#### 정적 타입과 동적 타입

-   **정적 타입 (Static Typing)**:

    -   **설명**: 변수의 타입이 프로그램 실행 전에 결정되면 코드 작성 중에 오류를 미리 발견할 수 있고, 프로그램이 더 빠르게 실행됩니다.
    -   **예시**: 이러한 특징을 가진건 C++와 Java 같은 언어입니다.

-   **동적 타입 (Dynamic Typing)**:

    -   **설명**: 변수의 타입이 프로그램 실행 중에 결정되면 코드 작성이 더 자유롭고 간편해집니다.
    -   **예시**: 이러한 특징을 가진건 JavaScript와 Python 같은 언어입니다.

### 2-2. 식별자와 변수

-   **변수 (Variable)**:

    -   **설명**: 변수는 데이터를 저장하는 공간입니다. 변수를 사용하면 프로그램에서 데이터를 저장하고, 필요할 때 이 데이터를 읽거나 변경할 수 있습니다.

-   **식별자 (Identifier)**:

    -   **설명**: 식별자는 변수, 함수, 클래스 등의 이름을 지칭하는 것입니다. 식별자를 통해 프로그래밍에서 변수나 함수를 구별하고 참조할 수 있습니다.

## 3. 변수 선언과 데이터 할당

### 3-1. 변수 선언

이제, 변수를 실제로 사용하는 방법에 대해 알아보겠습니다.

변수를 사용하기 전에 **변수 선언**을 해야 합니다. 변수 선언은 메모리에서 이 변수의 이름으로 공간을 확보하는 과정입니다.

-   **예시**:

    ```javascript
    var a;
    ```

    이 코드에서 `var a;`는 `a`라는 이름의 변수를 선언합니다. 이렇게 하면 메모리에 `a`라는 이름으로 비어있는 공간이 만들어집니다. 현재 `a`에는 아무 값도 저장되어 있지 않습니다.

#### 2. 데이터 할당

변수 선언 후에는 **데이터 할당**을 통해 변수에 실제 값을 저장할 수 있습니다. 데이터 할당은 변수에 저장할 값을 지정하는 과정입니다.

-   **예시**:

    ```javascript
    var a;
    a = 'abc'; // 'abc'라는 문자열을 변수 a에 저장합니다.
    ```

    위에있는 2줄 코드에서는 먼저 `a`라는 변수를 선언한 후, `a = 'abc';`를 통해 `'abc'`라는 문자열을 `a`에 저장합니다.

-   **선언과 할당을 동시에**:

    ```javascript
    var a = 'abc'; // 변수 a를 선언하고 'abc'를 바로 저장합니다.
    ```

    남은 한줄 코드에서는 변수 `a`를 선언하면서 동시에 `'abc'`라는 값을 저장합니다. 즉, 변수를 선언과 동시에 값을 할당할 수 있습니다.

**정리하자면**:

-   **변수 선언**은 메모리에 변수를 위한 공간을 예약하는 과정입니다.
-   **데이터 할당**은 이 변수에 실제 값을 저장하는 과정입니다. 선언과 할당을 동시에 할 수도 있습니다.

### 4. 기본형 데이터와 참조형 데이터

먼저, **기본형 데이터**에 대해 알아보겠습니다.

#### 4-1. 불변값

기본형 데이터는 **불변**입니다. 즉, 한번 생성된 값은 변경할 수 없고, 새로운 값을 만들게 됩니다. 예를 들어, 문자열을 생각해 볼까요:

```javascript
var a = 'abc';
a = a + 'def'; // 'abc'가 'abcdef'로 바뀌면서 새로운 문자열이 생성됩니다.
```

여기서 `a`는 처음에 'abc'라는 문자열을 가졌습니다. 이후 `a`에 'def'를 추가하면, 'abcdef'라는 새로운 문자열이 생성됩니다. 기존의 'abc'는 그대로 남아 있습니다. 즉, 기본형 데이터는 기존의 값을 직접 변경하지 않고 새로운 값을 만들어냅니다.

#### 4-2. 가변값

다음으로 **참조형 데이터**를 살펴보겠습니다. 참조형 데이터는 **가변**입니다. 즉, 생성된 데이터를 직접 수정할 수 있습니다. 예를 들어, 객체를 살펴보겠습니다:

```javascript
var obj1 = { a: 1, b: 'bbb' };
var obj2 = obj1; // obj1과 obj2는 같은 객체를 참조합니다.
obj2.c = 20; // obj1도 변경됩니다.
```

여기서 `obj1`과 `obj2`는 같은 객체를 참조합니다. `obj2`에서 값을 수정하면 `obj1`에서도 그 변화가 반영됩니다. 즉, 참조형 데이터는 같은 객체를 여러 변수가 공유하므로, 하나의 변수가 객체를 변경하면 다른 변수에서도 그 변경 사항이 보입니다.

### 5. 불변 객체

#### 5-1. 불변 객체 만들기

불변 객체를 만드는 방법 중 하나는, 기존 객체를 복사해서 새로운 객체를 생성하는 것입니다. 이렇게 하면 원본 객체는 그대로 유지되고, 새로운 객체만 변경할 수 있습니다. 예를 들어, 사용자 정보를 담고 있는 객체를 생각해 보겠습니다:

```javascript
var user = { name: 'Kim', gender: 'female' };
var changeName = function (user, newName) {
    return { ...user, name: newName };
};
```

여기서 `changeName` 함수는 기존의 `user` 객체를 변경하는 대신, 새로운 객체를 생성합니다. `...user` 구문은 기존 객체의 모든 속성을 복사하고, `name: newName`으로 이름만 변경된 새로운 객체를 반환합니다. 이렇게 하면 원본 `user` 객체는 영향을 받지 않고, 새로운 객체만 변경됩니다.

#### 5-2. 얕은 복사 vs 깊은 복사

불변 객체를 만들 때, 객체를 복사하는 두 가지 방법이 있습니다: **얕은 복사**와 **깊은 복사**입니다.

-   **얕은 복사 (Shallow Copy)**: 객체의 바로 아래 단계의 값만 복사합니다. 즉, 객체 안에 다른 객체가 있을 때 그 내부 객체는 복사하지 않고 참조만 복사됩니다.

얕은 복사의 예제를 보면:

```javascript
var copyObject = function (target) {
    var result = {};
    for (var prop in target) {
        result[prop] = target[prop];
    }
    return result;
};
```

이 함수는 `target` 객체의 속성만을 복사합니다. 만약 `target` 객체 안에 다른 객체가 있다면, 그 내부 객체는 그대로 참조만 복사됩니다.

-   **깊은 복사 (Deep Copy)**: 객체의 모든 값을 재귀적으로 복사합니다. 즉, 객체 안에 있는 객체들까지 모두 새로 복사하여 완전히 독립적인 객체를 생성합니다.

깊은 복사의 예제는 보면:

```javascript
var copyObjectDeep = function (target) {
    var result = {};
    if (typeof target === 'object' && target !== null) {
        for (var prop in target) {
            result[prop] = copyObjectDeep(target[prop]);
        }
    } else {
        result = target;
    }
    return result;
};
```

이 함수는 `target` 객체의 모든 속성을 재귀적으로 복사하여, 내부 객체들까지 모두 새로운 객체로 만들어냅니다. 이렇게 하면 원본 객체와 완전히 독립적인 복사본을 생성할 수 있습니다.

## 6. `undefined`와 `null`

### 6-1. `undefined`

**`undefined`**는 값이 대입되지 않은 변수나, 존재하지 않는 객체의 속성에 접근할 때 자동으로 설정되는 값입니다. 즉, 변수에 값이 할당되지 않았거나 객체에 해당 속성이 존재하지 않을 때 `undefined`가 나타납니다.

예를 들어:

```javascript
var a;
console.log(a); // undefined
```

여기서 변수 `a`는 값을 할당받지 않았기 때문에 `undefined`로 출력됩니다.

또 다른 예시로는:

```javascript
var obj = { a: 1 };
console.log(obj.a); // 1
console.log(obj.b); // 객체의 존재하지 않는 프로퍼티 접근 undefined
console.log(b); // 반환 값이 없는 함수
```

여기서 `obj` 객체는 `a`라는 속성을 가지고 있지만, `b`라는 속성은 존재하지 않기 때문에 접근 시 `undefined`가 반환됩니다. 하지만, `b`라는 변수를 직접 참조하려고 하면 `ReferenceError`가 발생합니다. 이는 `b`라는 변수가 아예 정의되지 않았기 때문입니다.

### 6-2. `null`

**`null`**은 명시적으로 '비어있음' 또는 '값이 없음'을 나타내기 위해 사용됩니다. 변수에 의도적으로 아무 값도 없다는 것을 표현하고자 할 때 사용됩니다.

예를 들어:

```javascript
var n = null;
console.log(n); // null
```

여기서 변수 `n`은 명시적으로 `null`로 설정되었습니다. `null`은 값이 없다는 것을 명확하게 표현합니다.
