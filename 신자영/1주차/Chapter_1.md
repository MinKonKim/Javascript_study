# 데이터 타입

![데이터 타입의 종류](https://github.com/user-attachments/assets/a7aaad18-e8c0-451f-b31a-3728fad85770)

## 1-1. 데이터 타입의 종류

JavaScript의 데이터 타입은 크게 두 가지로 나뉩니다:

1. **기본형 (Primitive Types)**

    - **number**: 숫자 타입
    - **string**: 문자열 타입
    - **boolean**: 참/거짓 값
    - **null**: 값이 없음을 나타내는 타입
    - **undefined**: 값이 정의되지 않았음을 나타내는 타입
    - **symbol**: 고유하고 변경 불가능한 값

    기본형 데이터는 할당/연산 시 값이 복제됩니다. 값이 담긴 주솟값을 직접 복제하며, 불변성(immutability)을 띄고 있습니다.

2. **참조형 (Reference Types)**

    - **object**: 객체 타입
        - **array**: 배열 타입
        - **function**: 함수 타입
        - **date**: 날짜 및 시간 타입
        - **regexp**: 정규 표현식 타입
        - **Map**: 키-값 쌍을 저장하는 객체
        - **WeakMap**: 가비지 컬렉션에 의한 메모리 해제를 지원하는 Map
        - **Set**: 유일한 값을 저장하는 집합
        - **WeakSet**: 가비지 컬렉션에 의한 메모리 해제를 지원하는 Set

    참조형 데이터는 할당/연산 시 참조가 복제됩니다. 값이 담긴 주솟값을 가리키는 주솟값이 복제됩니다.

## 1-2. 데이터 타입에 관한 배경지식

### 1-2-1 메모리와 데이터

![비트와 바이트](https://github.com/user-attachments/assets/7e74989c-b1de-4fcd-aefb-dba95087ea48)

-   **비트**: 0 또는 1의 두 가지 값을 표현할 수 있음.
-   **바이트**: 1바이트 = 8비트로 구성되어 있으며, 2의 8제곱 (256) 개의 값을 표현할 수 있음.
-   **바이트 생성 배경**: 비트 단위로 위치를 확인하는 것은 비효율적이며, 바이트 단위로 묶어 표현할 수 있는 값이 늘어나고 검색 시간이 줄어듭니다. 그러나 많은 비트를 한 단위로 묶으면 낭비되는 비트가 발생할 수 있습니다.

## 동적 타입 vs 정적 타입

-   **정적 타입의 언어** (예: C/C++, Java): 메모리 낭비를 최소화하기 위해 데이터 타입별로 메모리 영역을 할당합니다 (예: 2바이트, 4바이트 등).
-   **동적 타입의 언어** (예: JavaScript): 메모리 용량이 과거보다 커지면서 데이터 타입 구분 없이 64비트에 숫자를 저장합니다. 모든 데이터는 메모리의 주솟값을 통해 구분하고 연결할 수 있습니다.

### 1-2-2 식별자와 변수

-   **변수**: 변할 수 있는 데이터가 담길 수 있는 공간 또는 그릇.
-   **식별자**: 변수명으로, 데이터나 변수를 식별하는 데 사용하는 이름입니다.

## 1-3. **변수 선언과 데이터 할당**

### 1-3-1 변수 선언

"변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다"

변수 선언에 대한 메모리 영역의 변화

![변수 선언데 대한 메모리 영역의 변화](https://github.com/user-attachments/assets/2f36e7ab-4737-4886-bb5d-573e331ce89d)

-   변수확보: 메모리에서 비어있는 공간 하나를 확보한다. 1003

-   식별자: 이 공간의 이름을 a라고 지정한다. a

이후 사용자가 a에 접근하면

컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색(1003)하여

담긴 데이터를 반환한다.

# 1-3. 변수 선언과 데이터 할당

## 1-3-1 변수 선언

```
var a;
```

변수 선언은 "변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 `a`로 한다"라는 작업을 포함합니다.

### 변수 선언에 대한 메모리 영역의 변화

![변수 선언에 대한 메모리 영역의 변화](https://github.com/user-attachments/assets/2f36e7ab-4737-4886-bb5d-573e331ce89d)

-   **변수 확보**: 메모리에서 비어있는 공간 하나를 확보합니다. (예: `1003`)
-   **식별자**: 이 공간의 이름을 `a`로 지정합니다.

이후 사용자가 `a`에 접근하면 컴퓨터는 메모리에서 `a`라는 이름을 가진 주소(`1003`)를 검색하여 담긴 데이터를 반환합니다.

## 1-3-2 데이터 할당

```
var a;   // 변수 a 선언
a = 'abc'   // 변수 a에 데이터 할당

var a = 'abc'    // 변수 선언과 할당을 한 문장으로 표현
```

변수에 직접 문자열 'abc'를 저장하는 것이 아니라, 별도의 메모리 공간을 확보하여 문자열 'abc'를 저장하고, 그 주소를 변수 영역에 저장합니다.

### 데이터 할당에 대한 메모리 영역의 변화

![데이터 할당에 대한 메모리 영역의 변화](https://github.com/user-attachments/assets/d881241d-dc1e-4e7c-b6b8-81bdf4332a1b)

1. **변수 영역에서 빈 공간(@1003)을 확보**
2. **확보한 공간의 식별자를 `a`로 지정**
3. **데이터 영역의 빈 공간(@5004)에 문자열 'abc'를 저장**
4. **변수 영역에서 `a`라는 식별자를 검색(@1003)**
5. **앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입**

![문자열 변환에 대한 메모리 영역의 변화](https://github.com/user-attachments/assets/be5dab64-c0aa-404d-8462-6936c3b90ec4)

### 데이터 영역의 주소를 변수에 저장하는 이유

1. **데이터 변환을 자유롭게 하려는 목적**: 문자열 데이터는 다양한 형태로 변환될 수 있으며, 이를 효율적으로 처리하기 위해 변수와 데이터를 별도의 공간에 저장합니다.
2. **메모리를 효율적으로 관리하기 위한 목적**: 문자열 데이터는 가변적인 메모리 용량이 필요합니다. 영어는 1바이트, 한글은 2바이트 등 각각 다릅니다. 변수와 데이터를 별도로 관리하면 메모리 관리와 데이터 변환을 보다 효율적으로 할 수 있습니다.

이러한 방법은 중복된 데이터를 효율적으로 관리하는 데에도 도움이 됩니다.
