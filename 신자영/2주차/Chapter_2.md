# 2. 실행 컨텍스트 (Execution Context)

자바스크립트에서 실행 컨텍스트는 코드가 실행될 때 필요한 환경 정보를 모아놓은 객체입니다. 이 객체는 코드의 실행 순서와 환경을 제어합니다. 실행 컨텍스트는 콜 스택(Call Stack)에 쌓이며, 가장 위에 있는 컨텍스트의 코드가 실행됩니다.

## 2-1. 실행 컨텍스트란?

실행 컨텍스트는 자바스크립트 코드의 실행 환경을 정의하는 객체입니다. 주요 역할은 다음과 같습니다:

-   **호이스팅 (Hoisting):** 변수를 최상단으로 끌어올림
-   **외부 환경 정보 구성**
-   **`this` 값 설정**

실행 컨텍스트는 다음과 같은 방식으로 작동합니다:

1. **전역 컨텍스트:** 자바스크립트가 처음 실행될 때 생성됩니다.
2. **함수 호출:** 함수가 호출될 때마다 새로운 실행 컨텍스트가 생성됩니다.
3. **콜 스택:** 실행 컨텍스트는 콜 스택에 쌓이며, 가장 위에 있는 컨텍스트가 실행됩니다.

### 예시 코드

```javascript
// ------------------------------ (1)
var a = 1;
function outer() {
    function inner() {
        console.log(a); // undefined
        var a = 3;
    }
    inner(); // ------------------- (2)
    console.log(a); // 1
}
outer(); // -------------------- (3)
console.log(a); // 1
```

**설명:**

1. **전역 컨텍스트:** 자바스크립트 코드 실행 시 전역 컨텍스트가 콜 스택에 담깁니다.
2. **`outer` 함수 호출:** `outer` 함수가 호출되면 `outer` 실행 컨텍스트가 생성되고 콜 스택에 쌓입니다. 이로 인해 전역 컨텍스트의 실행이 일시 중단됩니다.
3. **`inner` 함수 호출:** `inner` 함수가 호출되면 `inner` 실행 컨텍스트가 생성되어 콜 스택의 가장 위에 쌓입니다. 이후 `inner` 함수의 코드가 실행됩니다.
4. **컨텍스트 종료:** `inner` 함수의 실행이 완료되면 `inner` 실행 컨텍스트가 콜 스택에서 제거됩니다. 다음으로 `outer` 함수의 나머지 코드가 실행됩니다.
5. **전역 컨텍스트 종료:** `outer` 함수의 실행이 완료되면 `outer` 실행 컨텍스트가 제거되고, 전역 컨텍스트만 남아 있습니다.

## 2-2. VariableEnvironment vs LexicalEnvironment

-   **VariableEnvironment:** 실행 컨텍스트 생성 시 변수와 함수 선언의 스냅샷을 유지합니다.
-   **LexicalEnvironment:** 현재 컨텍스트 내의 실시간 변수 정보를 반영합니다.

💡 왜 굳이 VariableEnvironment를 활용하여 스냅샷을 찍어두는 것일까?

1. 엔진 내부에서 그렇게 구현되어있을분 정확한 사용이유를 알진 못함
2. with함수를 사용할때 컨텍스트가 확장되면서 사용된다고 함

## 2-3. LexicalEnvironment의 구성 요소

#### 2-3-1. environmentRecord와 호이스팅

-   **environmentRecord**

    -   현재 컨텍스트와 관련된 식별자 정보를 저장합니다. 매개변수, 변수, 함수 식별자 등이 포함

💡 참고
전역 실행 컨텍스트는 변수 객체가 아닌 전역 객체를 활용한다.
전역 객체에는 브라우저의 window, node.js의 global 객체 등이 있다.
이들은 자바스크립트 내장 객체가 아닌 호스트 객체로 분류된다.

-   **호이스팅 (Hoisting):**

    -   자바스크립트가 코드를 실행하기 전에 변수와 함수 선언을 최상단으로 끌어올리는 과정
    -   변수와 함수 선언이 코드 상의 위치와 관계없이 사용가능

###### 호이스팅 규칙

-   **매개변수와 변수에 대한 호이스팅**:

    -   함수 내에서 매개변수와 변수 선언이 모두 호이스팅됩니다.
    -   변수 선언은 호이스팅되어 최상단으로 끌어올려지지만, 변수의 값 할당은 원래 위치에 남아 있습니다.

-   **함수 선언의 호이스팅**

    -   함수 선언은 전체가 호이스팅되며, 이로 인해 함수 정의를 코드 상의 어느 위치에서든 호출할 수 있습니다.
    -   반면에 함수 표현식은 변수처럼 취급되므로 변수 선언만 호이스팅됩니다.

###### 함수 선언문과 함수 표현식

-   **함수 선언문**은 (함수 이름과 함께 선언)전체가 호이스팅되기 때문에 함수 선언 전에 호출할 수 있다.

-   **함수 표현식**은 변수 선언만 호이스팅되며, 함수 정의가 변수에 할당된 후에만 호출할 수 있다.

-   즉, 함수 선언문은 전체가 호이스팅 되고 함수 표현식은 변수 선언 부분만 호이스팅 됨!

//함수 선언문의 위험성.

// 상대적으로 함수 표현식이 안정하다.
