# 2. 실행 컨텍스트 (Execution Context)

    -   자바스크립트에서 실행 컨텍스트는 코드가 실행될 때 필요한 환경 정보를 모아놓은 객체이다.
    -   이 객체는 코드의 실행 순서와 환경을 제어하며, 콜 스택(Call Stack)에 쌓인다. 가장 위에 있는 컨텍스트의 코드가 실행된다.

## 2-1. 실행 컨텍스트란?

    -   실행 컨텍스트는 자바스크립트 코드의 실행 환경을 정의하는 객체이다.

-   **호이스팅 (Hoisting):** 변수를 최상단으로 끌어올림
-   **외부 환경 정보 구성**
-   **`this` 값 설정**

실행 컨텍스트는 다음과 같은 방식으로 작동

1. **전역 컨텍스트:** 자바스크립트가 처음 실행될 때 생성
2. **함수 호출:** 함수가 호출될 때마다 새로운 실행 컨텍스트가 생성
3. **콜 스택:** 실행 컨텍스트는 콜 스택에 쌓이며, 가장 위에 있는 컨텍스트가 실행

### 예시 코드

```javascript
// ------------------------------ (1)
var a = 1;
function outer() {
    function inner() {
        console.log(a); // undefined
        var a = 3;
    }
    inner(); // ------------------- (2)
    console.log(a); // 1
}
outer(); // -------------------- (3)
console.log(a); // 1
```

**설명:**

1. **전역 컨텍스트:** 자바스크립트 코드 실행 시 전역 컨텍스트가 콜 스택에 담긴다.
2. **`outer` 함수 호출:** `outer` 함수가 호출되면 `outer` 실행 컨텍스트가 생성되고 콜 스택에 쌓입니다. 이로 인해 전역 컨텍스트의 실행이 일시 중단된다.
3. **`inner` 함수 호출:** `inner` 함수가 호출되면 `inner` 실행 컨텍스트가 생성되어 콜 스택의 가장 위에 쌓입니다. 이후 `inner` 함수의 코드가 실행된다.
4. **컨텍스트 종료:** `inner` 함수의 실행이 완료되면 `inner` 실행 컨텍스트가 콜 스택에서 제거된다. 다음으로 `outer` 함수의 나머지 코드가 실행된다.
5. **전역 컨텍스트 종료:** `outer` 함수의 실행이 완료되면 `outer` 실행 컨텍스트가 제거되고, 전역 컨텍스트만 남아 있다.

## 2-2. VariableEnvironment vs LexicalEnvironment

-   **VariableEnvironment:** 실행 컨텍스트 생성 시 변수와 함수 선언의 스냅샷을 유지
-   **LexicalEnvironment:** 현재 컨텍스트 내의 실시간 변수 정보를 반영

💡 왜 굳이 VariableEnvironment를 활용하여 스냅샷을 찍어두는 것일까?

> 1. 엔진 내부에서 그렇게 구현되어있을분 정확한 사용이유를 알진 못함
> 2. with함수를 사용할때 컨텍스트가 확장되면서 사용된다고 함

## 2-3. LexicalEnvironment의 구성 요소

#### 2-3-1. environmentRecord와 호이스팅

-   **environmentRecord**

    -   현재 컨텍스트와 관련된 식별자 정보를 저장
    -   매개변수, 변수, 함수 식별자 등이 포함

💡 참고

> 전역 실행 컨텍스트는 변수 객체가 아닌 전역 객체를 활용한다.
> 전역 객체에는 브라우저의 window, node.js의 global 객체 등이 있다.
> 이들은 자바스크립트 내장 객체가 아닌 호스트 객체로 분류된다.

-   **호이스팅 (Hoisting):**

    -   자바스크립트가 코드를 실행하기 전에 변수와 함수 선언을 최상단으로 끌어올리는 과정
    -   변수와 함수 선언이 코드 상의 위치와 관계없이 사용가능

###### 호이스팅 규칙

-   **매개변수와 변수에 대한 호이스팅**:

    -   함수 내에서 매개변수와 변수 선언이 모두 호이스팅된다.
    -   변수 선언은 호이스팅되어 최상단으로 끌어올려지지만, 변수의 값 할당은 원래 위치에 남아 있습니다.

-   **함수 선언의 호이스팅**

    -   함수 선언은 전체가 호이스팅되며, 이로 인해 함수 정의를 코드 상의 어느 위치에서든 호출할 수 있습니다.
    -   반면에 함수 표현식은 변수처럼 취급되므로 변수 선언만 호이스팅된다.

###### 함수 선언문과 함수 표현식

-   **함수 선언문**

    -   정의 방법: `function functionName() { /* 함수 본문 */ }`
    -   호이스팅: 전체 함수가 호이스팅되어 함수가 정의되기 전에도 호출할 수 있음. 이로 인해 코드의 상단에서 호출이 가능하고, 마지막으로 정의된 함수가 유효해지므로, 이전에 정의된 함수는 덮어씌워질 수 있음.

-   **함수 표현식**

    -   정의 방법: 함수 표현식을 변수에 할당하는 방식
    -   호이스팅: 변수명만 호이스팅되며, 함수 정의는 호이스팅되지 않음. 따라서 함수 정의 후에만 호출할 수 있으며, 함수 정의 이전에 호출하면 오류가 발생함.

-   **기명 함수 표현식**

    -   정의 방법: 함수에 이름을 부여하여 변수에 할당하는 방식
    -   특징: 디버깅 시 함수 이름이 표시되어 오류 추적에 유리함.

-   **익명 함수 표현식**

    -   정의 방법: 함수에 이름을 부여하지 않고 변수에 할당하는 방식
    -   특징: 디버깅 시 함수 이름이 표시되지 않음.

💡 참고

> 기명 함수 표현식은 외부에서 함수명으로 함수를 호출할 수 없다. 그럼 왜 사용될까?
> 과거의 익명 함수 표현식의 함수명은 undefined 또는 unnamed라는 값이 나왔었다. 이 때문에 기명 함수 표현식이 디버깅 시 어떤 함수인지 추적하기에 익명 함수 표현식보다 유리한 측면이 있었다. 하지만 익명도 이제는 name 프로퍼티가 할당된다.
