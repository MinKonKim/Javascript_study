### 실행 컨텍스트 (Execution Context)

자바스크립트에서 실행 컨텍스트는 코드가 실행될 때 필요한 환경 정보를 모아 놓은 객체입니다. 이 객체는 코드의 실행 순서와 환경을 제어하며, 콜 스택(Call Stack)에 쌓입니다. 가장 위에 있는 컨텍스트의 코드가 실행됩니다.

---

## 1. 실행 컨텍스트란?

**실행 컨텍스트**는 자바스크립트 코드의 실행 환경을 정의하는 객체입니다. 주로 다음과 같은 역할을 합니다:

-   **호이스팅 (Hoisting):** 변수와 함수 선언을 최상단으로 끌어올림
-   **외부 환경 정보 구성:** 함수가 선언된 위치와 외부 변수 정보 유지
-   **`this` 값 설정:** 현재 실행되는 코드가 어떤 객체를 참조할지 결정

### 실행 컨텍스트의 동작 방식

1. **전역 컨텍스트:** 자바스크립트가 처음 실행될 때 생성됩니다. 모든 전역 변수와 함수는 전역 컨텍스트에서 정의됩니다.
2. **함수 호출:** 함수가 호출될 때마다 새로운 실행 컨텍스트가 생성됩니다.
3. **콜 스택:** 실행 컨텍스트는 콜 스택에 쌓이며, 가장 위에 있는 컨텍스트의 코드가 실행됩니다.

### 예제 코드

```javascript
var a = 1;
function outer() {
    function inner() {
        console.log(a); // undefined
        var a = 3;
    }
    inner();
    console.log(a); // 1
}
outer();
console.log(a); // 1
```

**설명:**

1. **전역 컨텍스트:** 자바스크립트 코드 실행 시 전역 컨텍스트가 콜 스택에 담깁니다.
2. **`outer` 함수 호출:** `outer` 함수가 호출되면 `outer` 실행 컨텍스트가 생성되고 콜 스택에 쌓입니다.
3. **`inner` 함수 호출:** `inner` 함수가 호출되면 `inner` 실행 컨텍스트가 생성되어 콜 스택의 가장 위에 쌓입니다. `inner` 함수의 코드가 실행됩니다.
4. **컨텍스트 종료:** `inner` 함수의 실행이 완료되면 `inner` 실행 컨텍스트가 콜 스택에서 제거됩니다. 다음으로 `outer` 함수의 나머지 코드가 실행됩니다.
5. **전역 컨텍스트 종료:** `outer` 함수의 실행이 완료되면 `outer` 실행 컨텍스트가 제거되고, 전역 컨텍스트만 남아 있습니다.

---

## 2. VariableEnvironment vs LexicalEnvironment

-   **VariableEnvironment:** 실행 컨텍스트 생성 시 변수와 함수 선언의 스냅샷을 유지합니다.
-   **LexicalEnvironment:** 현재 컨텍스트 내의 실시간 변수 정보를 반영합니다.

### VariableEnvironment 사용 이유

-   엔진 내부에서 구현된 방식으로, 코드의 실행 환경과 변수를 정확히 추적할 수 있도록 합니다.

---

## 3. LexicalEnvironment의 구성 요소

### 3-1. environmentRecord와 호이스팅

-   **environmentRecord:**

    -   현재 컨텍스트와 관련된 식별자 정보를 저장합니다.
    -   매개변수, 변수, 함수 식별자 등이 포함됩니다.

-   **호이스팅 (Hoisting):**
    -   자바스크립트가 코드를 실행하기 전에 변수와 함수 선언을 최상단으로 끌어올리는 과정입니다.
    -   변수와 함수 선언은 코드의 위치와 관계없이 사용 가능합니다.

#### 호이스팅 규칙

-   **매개변수와 변수의 호이스팅:**

    -   함수 내에서 매개변수와 변수 선언이 모두 호이스팅됩니다.
    -   변수 선언은 호이스팅되어 최상단으로 이동하지만, 변수의 값 할당은 원래 위치에 남아 있습니다.

    ```javascript
    function a(x) {
        console.log(x); // (1)
        var x; // (2)
        console.log(x); // (3)
        var x = 2; // (4)
        console.log(x); // (5)
    }
    a(1);
    ```

    변수 선언은 호이스팅되어 최상단으로 이동하고, 값 할당은 원래 위치에 있기 때문입니다.

-   **함수 선언의 호이스팅:**

    -   함수 선언은 전체가 호이스팅되어 함수가 정의되기 전에도 호출할 수 있습니다.
    -   함수 표현식은 변수처럼 취급되므로 변수 선언만 호이스팅됩니다.

    ```javascript
    function a() {
        console.log(b); // (1)
        var b = 'bbb'; // (2)
        console.log(b); // (3)
        function b() {} // (4)
        console.log(b); // (5)
    }
    a();
    ```

    함수 선언문은 전체가 호이스팅되며, 변수 `b`는 재할당되기 때문에 마지막 출력에서 `bbb`가 보입니다.

---

#### 함수 선언문과 함수 표현식의 차이

-   **함수 선언문:**

    -   정의 방법: `function functionName() { /* 함수 본문 */ }`
    -   호이스팅: 전체 함수가 호이스팅되어 함수가 정의되기 전에도 호출할 수 있습니다.

    ```javascript
    console.log(sum(1, 2)); // 3

    function sum(a, b) {
        return a + b;
    }
    ```

-   **함수 표현식:**

    -   정의 방법: 함수를 변수에 할당하는 방식
    -   호이스팅: 변수명만 호이스팅되며, 함수 정의는 호이스팅되지 않아서 함수 정의 후에만 호출할 수 있습니다.

    ```javascript
    console.log(mutiply(1, 2)); // TypeError: mutiply is not a function

    var mutiply = function (a, b) {
        return a * b;
    };
    ```

-   **기명 함수 표현식:**

    -   정의 방법: 함수에 이름을 부여하여 변수에 할당하는 방식
    -   특징: 디버깅 시 함수 이름이 표시되어 오류 추적에 유리합니다.

-   **익명 함수 표현식:**
    -   정의 방법: 함수에 이름을 부여하지 않고 변수에 할당하는 방식
    -   특징: 디버깅 시 함수 이름이 표시되지 않습니다.
