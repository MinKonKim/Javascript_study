##### 질문 답

첫번째 질문
클래스 및 상속 부분 this. 값이 다른 이유 바인딩이 왜 다른지

자바스크립트에서 this의 바인딩은 함수 호출 방식에 따라 다르다.

-   ES5와 ES6 모두에서 정적 메서드에서 this는 클래스 자체를 가리키지만, name 속성이 클래스에 정의되어 있지 않기 때문에 undefined를 반환
-   인스턴스 메서드에서 this는 인스턴스를 가리키므로 인스턴스를 생성할 때 전달한 name 값을 사용할 수 있다.

이와 같은 차이로 인해 this의 값이 다르게 바인딩되며, staticMethod에서 this는 클래스 자체를 가리키고, 인스턴스 메서드에서는 생성된 인스턴스를 가리킵니다.

두번째 질문
클래스 es6 클래스 문법에서 constructor는 ES5의 생성자 함수와 동일한 역할을 수행하는데 왜 다르게 동작하느냐

이 두 코드 블록은 비슷한 역할을 수행하지만, getArea 메서드를 정의하면서 반환값과 출력 방식이 다르기 때문에 동작하는 방식이 다르다.

첫 번째 코드 블록 (Square 클래스의 getArea):

```
getArea() {
    console.log('size: ', super.getArea());
}
```

-   이 메서드는 부모 클래스인 Rectangle의 getArea 메서드를 호출
-   super.getArea()를 통해 면적을 계산하고, 그 결과를 콘솔에 출력 즉, 메서드의 결과값을 반환하지 않고, 콘솔에 출력하는 것에 초점을 맞춤

두 번째 코드 블록 (Rectangle 클래스의 getArea):

```
    getArea() {
        return this.width * this.height;
    }
```

-   이 메서드는 width와 height의 곱을 계산하여 반환 즉, 면적을 계산한 값을 호출한 쪽에 반환
-   따라서 이 메서드는 값을 반환하며, 이 값을 다른 변수에 저장하거나 사용할 수 있다.

3번째 질문
Static Method의 다른 용도
유틸리티 함수: 숫자 연산, 문자열 조작, 데이터 포맷팅 등.
팩토리 메서드: 특정 조건에 따라 인스턴스를 다르게 생성하거나, 초기화 로직을 통일하는 경우.
싱글턴 패턴: 애플리케이션에서 단 하나만 존재해야 하는 객체(예: 설정 관리, 데이터베이스 연결 등).
클래스 레벨에서 상태 관리: 전역적으로 관리되는 카운터, 설정 또는 상태.
클래스 관련 정보 제공: 애플리케이션의 버전 정보, 클래스의 메타데이터 등을 반환하는 경우.

동적에서 -> 정적으로
정적 메서드(static method)가 동적 메서드(instance method)에서 정적으로 변화한 배경에는 성능 향상, 유틸리티 메서드로의 활용, 상태 공유 및 구조적 디자인 패턴과의 관련성이 있으며, 정적 메서드는 클래스에 직접 연결되어 있어 인스턴스를 생성할 필요가 없고, 특정 기능이 객체의 상태와 무관할 때 간편하게 사용할 수 있다. 또한 클래스 레벨에서 공유되는 데이터나 메서드를 관리할 수 있어, 팩토리 패턴이나 싱글톤 패턴과 같은 디자인 패턴에서 중요한 역할을 하며 코드의 가독성을 높이고 사용성을 향상시킵니다.

정적메서드 사용이유
정적 메서드의 사용 이유는 성능 최적화, 유틸리티 함수 제공, 전역 상태 관리, 객체 생성 제어, 그리고 코드의 가독성과 유지보수성 향상 등으로, 객체의 상태에 의존하지 않고 독립적으로 기능을 수행할 수 있기 때문입니다.
