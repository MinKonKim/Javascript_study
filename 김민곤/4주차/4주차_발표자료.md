# Chapter 3 this
## 상황에 따라 달라지는 this
- this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정됩니다.
- this는 함수를 호출할 때 결정된다고 할 수 있다.

### **!!key point!!**

> this가 어떤 값을 보게 되는지를 살펴보고, 가능하면 그 원인도 함께 알아보자!!


**1. 전역 공간에서의 this**
  - 전역 공간에서 this는 전역 객체를 가리킵니다.
  - 브라우저 환경에서는 window 이고, Node.js 환경에서는 global 입니다.
  - 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다.
  ```javascript
    console.log(this===window); //true 
  ```
  ```javascript
    var a =1;
    console.log(a);        // 1 ----- (1)
    console.log(window.a); // 1 ----- (2)
    console.log(this.a);   // 1 ------(3)
  ```
  (1) 스코프 체인에서 a를 검색하다가 가장 마지막에 도달하는 전역 스코프의 Lexical Environment, 즉 전역객체에서 해당
  프로퍼티 **a를** 발견해서 그 값을 반환하기 때문입니다.
  (2),(3) 전역객체의 프로퍼티로 할당된 a를 반환.
     
  > 어? 그러면 var로 변수를 선언하는 대신 window의 프로퍼티에 직접 할당 하더라도 결과적으로는 var로 선언한 것과 똑같이 동작 하는거아냐?
  
   
  - 하지만, 전역변수 선언과 전역객체의 프로퍼티 할당 사이에 전혀 다른 경우도 있습니다. 바로 '삭제' 명령에 대해 그렇습니다.
                                                                                                                                                  
  ```javascript
  var a = 1
  delete window.a;                // false
  console.log(a,window.a,this.a)  // 1 1 1
   ```
  ```javascript
  window.c =3;
  delete window.c;                // true
  console.log(c,window.c,this.c); // Uncaught ReferenceError: c is not defined
  ```
  
  - 위의 예제 처럼, 처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제가 되는 반면 전역변수로 선언한 경우에는 삭제가 되지 않는 것을 확인할 수 있습니다.
  - 이처럼 var로 선언한 전역변수와 전역객체의 프로퍼티는 호이스팅 여부 및 configurable(변경 및 삭제 가능성) 여부에서 차이를 보입니다. 
      
**2. 메서드로서 호출할 때 그 메서드 내부에서의 this**
     ```javascript
     var func =function (x){
       console.log(this,x);
     };
     func(1);    // Window{...} 

     var obj ={
       method :func
     };
     obj.method(2)' // {method: f} 
     ```
     - 익명함수는 그대로인데 이를 변수에 담아 호출한 경우와 obj 객체의 프로퍼티에 할당해서 호출한 경우에 this가 달라지는 것입니다.
     - this에는 호출한 주체에 대한 정보가 담깁니다.
     - 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체입니다, 점 표기법의 경우 마지막 점 앞에 명시된 객체 곧 this가 되는 것.
     ```javascript
     // 메서드 내부에서의 this

      var obj={
          methodA: function(){console.log(this);},
          inner:{
            methodB: function(){console.log(this);}
          }
      };
      obj.methodA();          //  {methodA:f,inner:{...}} (=== obj)
      obj['methodA']();       //  {methodA:f,inner:{...}} (=== obj)c

      obj.inner.methodB();      // {methodB: f } (===obj.inner)
      obj.inner['methodB']();   // {methodB: f } (===obj.inner)
      obj['inner'].methodB();   // {methodB: f } (===obj.inner)
      obj['inner']['mthodB'](); // {methodB: f } (===obj.inner)
      
     ```

**3. 함수로서 호출할 때 그 함수 내부에서의 this**      
1) 함수 내부에서의 this
   + 함수에서의 this는 전역 객체를 가리킵니다.
   + 더글라스 크락포드는 이를 명백한 설계상의 오류라고 지적합니다.
2) 
    
    
