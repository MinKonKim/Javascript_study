# 02. 실행 컨텍스트

## 스택
- 스택은 `LIFO`(Last In, First Out) 구조로, 가장 마지막에 추가된 데이터가 가장 먼저 제거되는 방식이다.
- 즉, 마지막에 들어온 데이터가 가장 먼저 나간다.
<br/>

## 큐
- 큐는 `FIFO`(First In, First Out) 구조로, 가장 먼저 추가된 데이터가 가장 먼저 제거되는 방식이다.
- 즉, 처음 들어온 데이터가 가장 먼저 나간다.
<br/>

## 실행 컨텍스트
- 실행 컨텍스트는 실행할 코드에 필요한 환경 정보를 모아놓은 객체입니다. 이를 콜 스택에 쌓아두고, 가장 위에 쌓인 컨텍스트 코드를 실행하여 전체 코드의 환경과 순서를 보장합니다.
<br/>

## 실행 컨텍스트의 생성
- 실행 컨텍스트는 전역 공간이나 eval() 함수 등을 통해 자동으로 생성됩니다. 일반적으로는 함수를 실행하는 것만으로 구성됩니다.
- 자바스크립트 코드가 실행되면 전역 컨텍스트가 콜 스택에 담깁니다. 전역 컨텍스트는 특별한 개념이 아니며, 코드 실행 시 자동으로 활성화됩니다.
<br/>

## 콜 스택의 동작
- 콜 스택 구조에서 새로운 실행 컨텍스트가 맨 위에 쌓이게 되면, 해당 컨텍스트가 현재 실행할 코드에 관여하게 됩니다. 기존의 컨텍스트는 아래로 내려갑니다.
<br/>

## 실행 컨텍스트의 구성
실행 컨텍스트가 활성화될 때, 자바스크립트 엔진은 다음과 같은 환경 정보를 수집하여 실행 컨텍스트 객체에 저장합니다. 이 객체는 개발자가 코드로 확인할 수는 없습니다.
<br/>

### 1. Variable Environment (변수 환경):
- 현재 컨텍스트 내의 식별자 정보와 외부 환경 정보를 포함합니다.
- `변수 선언 시점`의 `렉시컬 환경 스냅샷`으로, 이후 변경 사항은 반영되지 않습니다.
<br/>

### 2. Lexical Environment (렉시컬 환경):
- 처음에는 변수 환경과 같지만, 이후 변경 사항이 `실시간`으로 반영됩니다.
<br/>

### 3. This Binding (this 바인딩):
- this 식별자가 가리켜야 할 대상 객체를 나타냅니다.
- 이와 같이 실행 컨텍스트는 코드 실행 시 필요한 다양한 정보를 저장하고, 자바스크립트 엔진이 코드를 효과적으로 실행하는 데 도움을 줍니다.
<br/>

## Variable Enviroment (변수 환경)
- `변수 환경(Variable Environment)`에는 `렉시컬 환경(Lexical Environment)`과 같은 정보가 담기지만, 최초 실행 시의 스냅샷을 유지한다는 점이 다릅니다.
- 실행 컨텍스트가 생성될 때, 먼저 변수 환경에 정보를 담고, 이를 복사하여 렉시컬 환경을 만듭니다.
- 이후에는 주로 렉시컬 환경을 활용하게 됩니다.
- 변수 환경과 렉시컬 환경의 내부는 `환경 레코드(Environment Record)`와 `외부 환경 참조(Outer Environment Reference)`로 구성되어 있습니다.
- 초기화 과정에서는 두 환경이 사실상 동일하지만, 코드 실행이 진행됨에 따라 서로 달라지게 됩니다. 이 점은 렉시컬 환경을 통해 좀 더 자세히 살펴보겠습니다.
<br/>

## Lexical Enviromnet (렉시컬 환경)
- `렉시컬 환경(Lexical Environment)`에 대한 한국어 번역은 여러 가지가 있지만, "어휘적 환경"이나 "정적 환경"이라는 표현이 많이 사용됩니다.
- "어휘적"이라는 용어는 영어 단어를 그대로 번역한 느낌이 강해 이해하기 어렵고, "정적"이라는 표현도 환경 정보가 자주 변하는 렉시컬 환경의 특성을 잘 설명하지 않습니다.
- 그래서 "사전적 환경"이라는 표현이 더 적절하다고 생각합니다. 이는 코드의 구조에 따라 변수가 어떻게 정의되고 접근되는지를 잘 나타내기 때문입니다.
<br/>

## EnviromentRecord와 호이스팅
## Environment Record (환경 레코드)
- `환경 레코드(Environment Record)`는 현재 컨텍스트와 관련된 코드의 식별자 정보를 저장하는 객체입니다.
- 이곳에는 함수에 지정된 매개변수, 선언된 함수 자체, var로 선언된 변수의 식별자 등이 포함됩니다.
- 즉, 컨텍스트 내부의 모든 식별자를 처음부터 끝까지 순서대로 수집합니다.
<br/>

## 전역 실행 컨텍스트
- 전역 실행 컨텍스트는 변수 객체를 생성하는 대신, JavaScript 환경이 제공하는 전역 객체를 활용합니다.
- 브라우저에서는 window 객체, Node.js에서는 global 객체가 이에 해당합니다.
- 이들은 JavaScript 내장 객체가 아니라 호스트 객체로 분류됩니다.
<br/>

## 코드 실행 전의 상태
- 변수 정보를 수집하는 과정이 끝나더라도, 아직 실행 컨텍스트가 관여할 코드는 실행되지 않은 상태입니다.
- JavaScript 엔진은 실행되기 전부터 해당 환경에 속한 변수명들을 모두 알고 있습니다.
- 이 때문에 "JavaScript 엔진이 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다"라고 이해해도 큰 문제가 없습니다.
<br/>

## 호이스팅  
- 호이스팅이란 "끌어올리다"라는 의미의 hoist에 ing를 붙여 만든 동명사로,
- 변수 정보 수집 과정을 쉽게 설명하기 위한 개념입니다.
- 실제로 JavaScript 엔진이 변수를 끌어올리지는 않지만, 편의상 그렇게 간주하는 것입니다.
<br/>

## 함수 선언문과 함수 표현식
- 호이스팅을 이해할 때 함께 알아두면 좋은 개념이 함수 선언문과 함수 표현식입니다.
<br/>

## 함수 선언문
- 함수 선언문은 function 키워드를 사용하여 함수를 정의하는 방식입니다.
- 이 경우 함수명은 반드시 정의되어야 합니다.
- 호이스팅 시, `전체 함수`가 `호이스팅`되어 함수가 정의되기 전에도 호출할 수 있습니다.
- ```
  function greet() {
    console.log("안녕하세요!");
  }

  // 함수 호출
  greet(); // 출력: 안녕하세요!

  ```
<br/>

## 함수 표현식
- 함수 표현식은 함수를 변수에 할당하는 방식입니다.
- 함수명은 선택사항이며, 이름이 없는 경우를 익명 함수 표현식이라고 합니다.
- 함수명을 정의한 경우를 기명 함수 표현식이라고 부릅니다.
- 이 두 가지 방식은 함수 정의 시의 동작 방식에 차이가 있으며, 호이스팅에 영향을 미칩니다. 함수 선언문은 전체 코드 실행 전에 호이스팅되지만, 함수 표현식은 그렇지 않다는 점에서 차이가 있습니다.
- 호이스팅 시, `변수명`만 `호이스팅`되며, 함수 정의 부분은 호이스팅되지 않습니다.
- 함수가 정의된 후에만 사용할 수 있으며, 그렇지 않으면 ReferenceError가 발생합니다.
- 함수 표현식을 사용할 때는 항상 `정의된 후에 호출`하도록 코드를 작성하는 것이 중요합니다.
- ```
  const greet = function() {
    console.log("안녕하세요!");
  };

  // 함수 호출
  greet(); // 출력: 안녕하세요!

  ```  
<br/>
