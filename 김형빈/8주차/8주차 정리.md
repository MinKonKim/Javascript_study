<h1>프로토타입</h1>

- 자바스크립트는 프로토타입 기반의 언어
- 클래스 기반의 언어에서는 `상속`을 사용한다
- 프로토타입 기반의 언어에서는 어떤 객체를 원형으로 삼고 이를 복제함으로써 `상속`과 비슷한 효과를 얻는다.

><h2>프로토타입의 개념 이해</h2>
constructor, prototype, instance

```js
var instance = new Constructor();
```

이를 그림으로 표현하면

- 어떤 생성자 함수(Constructor)를 new 연산자와 함께 호출하면
- Constructor에서 정의된 내용을 바탕으로 새로운 instance가 생성된다.
- 이때 instance에는 __proto__라는 프로퍼티가 자동으로 부여되는데,
- 이 프로퍼티는 Constructor의 prototype이라는 프로퍼티를 참조한다.

```js
Constructor.prototype === instance.__proto__
```

><h3>프로토타입 사용 예시</h3>

```js
var Person = function (name) {
    this._name = name;
};

Person.prototype.getName = functoin() {
    return this._name;
}

var suzi = new Person('Suzi');
suzi.__proto__.getName(); //undefined
```

- 프로토타입을 통해서 getName을 suzi 인스턴스로 복제하였다.
- 그러나 `suzi.__proto__.getName()`의 결과는 undefined가 나온다.
- `TypeError`가 발생하지 않았으므로 getName 함수를 잘 전달해주었다.
- 그렇다면 원인은 무엇일까??

><h3>프로토타입 사용 예시 오류 해결</h3>

- 원인은 `this`에 있다.
- 어떤 함수를 메서드로서 호출 할 때는 메서드명 바로 앞의 객체가 곧 this가 된다. 즉 getName 함수의 `this`는 `suzi`가 아니라 `suzi.__proto__`인 것이다. 
- 그런데 `suzi.__proto__`에는 name이 없으므로 undefined가 반환된다.
- 위의 코드에서 undefined가 나오는 문제를 해결하려면 어떤 방법이 있을까??

1. __proto__객체에 name 프로퍼티를 넣는다.
```js
var suzi = new Person('Suzi');
suzi.__proto__._name = 'SUZI';
suzi.__proto__.getName(); //SUZI
```

- `suzi.__proto__` 객체에 name 프로퍼티를 부여하여 `SUZI` 이름을 출력하였다.
- 그러나 여전히 `getName()`의 `this`가 suzi.__proto__를 가르키고 있다.

2. 메서드를 호출할 때 __proto__를 생략한다.
```js
var suzi = new Person('Suzi');
suzi.getName(); //Suzi
```

- `__proto__`를 생략하면 this는 instance가 된다.
- 그러나 `suzi.__proto__` 객체에 있는 getName() 메서드를 정상적으로 호출할 수 있고, 원하는 값이 나오는 건 이상하게 느껴진다.
- 이는 `__proto__`가 생략 가능한 프로퍼티이기 떄문
- 따라서 생성자 함수의 prototype에 어떤 메서드나 프로퍼티가 있다면 인스턴스에서도 마치 자신의 것처럼 해당 메서드나 프로퍼티에 접근할 수 있다.

><h3>Constructor</h3>
- 자기 자신을 참조하는 프로퍼티
- 자기 자신에 대한 정보가 필요한 이유? -> 인스턴스로부터 그 원형이 무엇인지 알 수 있는 수단이 필요하기 때문!

```js
var arr = [1, 2];
Array.prototype.constructor === Array // true
arr.__proto__.constructor === Array // true
arr.constructor === Array // true

var arr2 = new arr.constructor(3, 4);
console.log(arr2);  //[3, 4]
```

- `__proto__`가 생략 가능하기 때문에 인스턴스에서 직접 constructor에 접근할 수 있는 수단이 생겼다

```js
var arr;
arr.constructor = Array;
arr instanceof Arr;
```

><h2>프로토타입 체인</h2>

<h3>메서드 오버라이드</h3>

```js
var Person = function (name) {
    this.name = name;
}
Person.prototype.getName = function () {
    return this.name;
}

var iu = new Person('지금');
iu.getName = function () {
    return '바로 ' + this.name;
};

console.log(iu.getName()) // 바로 지금
```

- `iu.__proto__.getName`이 아닌 `iu` 객체에 있는 `getName`메서드가 호출됨
- 자바스크립트 엔진은 가장 가까운 대상인 자신의 프로퍼티를 검색한 후, 없으면 그다음으로 가까운 대상인 __proto__를 검색
- `iu.__proto__.getName`도 여전히 존재한다.

```js
console.log(iu.__proto__.getName()); //undefined
Person.prototype.name = '이지금';
console.log(iu.__proto__.getName()); // 이지금
```

-`getName`에서 this가 prototype을 바라보는 문제는 call이나 apply를 통해서 해결 가능

```js
console.log(iu.__proto__.getName.call(iu)); //지금
```


