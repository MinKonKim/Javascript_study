<h1>클로저</h1>

- 함수와 그 함수가 선언된 렉시컬 환경과의 조합 (MDN)

<h2>코드 예시</h2>

```js
const outer = function () {
  let a = 1;
  const inner = function () {
    return ++a;
  };
  
  return inner;
};

const out = outer();

console.info(out()); // 2
console.info(out()); // 3
```

<h2>콜스택 흐름</h2>

1. 빈 스택
2. 전역 컨텍스트 push
3. outer 컨텍스트 push
4. outer 실행
    - 전역 environmentRecord의 out에 inner 할당
5. outer 삭제
6. outer는 삭제 되었지만 inner의 LexicalEnvironment(outerEnvironmentReference)에서 a 값을 참조

<h2>클로저의 활용</h2>

- 상태(state)가 의도치 않게 변경되지 않도록 안전하게 은닉한다
- 특정 함수에게만 상태 변경을 허용하여 안전하게 변경하고 유지한다


**예제1**
```javascript
// 카운트 상태 변경 함수 #1
let num = 0;

const increase = function () {
    return ++num;
};

console.log(increase());
// num = 100; // 치명적인 단점이 있다
console.log(increase());
console.log(increase());
```
- 카운트 상태(num 변수의 값)는 increase 함수만이 변경할 수 있어야 한다
- 전역변수인 num이 문제이다

**예제2**
```javascript
// 카운트 상태 변경 함수 #2
const increase = function () {
  let num = 0;
  
  return ++num;
};

// 이전 상태값을 유지 못함
console.log(increase()); //1
console.log(increase()); //1
console.log(increase()); //1
```
- 의도치 않은 변경은 방지했다
- 그러나 increase()가 호출될 때마다 num이 초기화된다

**예제3**
```javascript
// 카운트 상태 변경 함수 #3
const increase = (function () {
  let num = 0;
  
  // 클로저
  return function () {
    return ++num;
  };
})();

// 이전 상태값을 유지
console.log(increase()); //1
console.log(increase()); //2
console.log(increase()); //3
```
 - 의도한 대로 동작한다
 
**예제4 (decrease 추가)**
```javascript
// 카운트 상태 변경 함수 #4
// 클로저 카운트 기능 확장(값 감소 기능 추가)
const counter = (function () {
  //카운트 상태 변수
  let num = 0;

  // 클로저인 메서드(increase, decrease)를 갖는 객체를 반환한다
  // property는 public -> 은닉되지 않는다
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return num > 0 ? --num : 0;
    },
  };
})();

console.log(counter.increase()); // 1
console.log(counter.increase()); // 2

console.log(counter.decrease()); // 1
console.log(counter.decrease()); // 0
```
**예제5**
```javascript
// 생성자 함수
function Person(name, age) {
  this.name = name; //public
  let _age = age; //private

  // 인스턴스 메서드
  // 따라서, Person 객체가 생성될 때 마다 중복 생성됨
  // : 해결방법 -> prototype
  this.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
  };
}

const me = new Person("Choi", 33);
me.sayHi(); // Hi!, My name is Choi. I am 33.
console.log(me.name); // Choi
console.log(me._age); // undefined

const you = new Person("Lee", 30);
you.sayHi(); // Hi! My name is Lee. I am 30.
console.log(you.name); // Lee
console.log(you.age); // undefined
```
- **캡슐화**
- `프로퍼티`와 `메서드`를 하나로 묶는 것
- 목적
  - 객체의 상태 변경을 방지함으로써 정보 보호
  - 객체 간의 의존성(결합도 - coupling)을 낮춤
