<h1>클로저</h1>

- 함수와 그 함수가 선언된 렉시컬 환경과의 조합 (MDN)

<h2>코드 예시</h2>

```js
const outer = function () {
  let a = 1;
  const inner = function () {
    return ++a;
  };
  
  return inner;
};

const out = outer();

console.info(out()); // 2
console.info(out()); // 3
```

<h2>콜스택 흐름</h2>

1. 빈 스택
2. 전역 컨텍스트 push

![image](https://github.com/user-attachments/assets/9db68e38-9734-423e-8fbd-b961acb545cf)

3. outer 컨텍스트 push
5. outer 실행
    - 전역 environmentRecord의 out에 inner 할당

![outer 실행 시 콜스택](https://github.com/user-attachments/assets/b80f2f26-7aa8-48b4-9281-a58d362012a1)

6. outer 삭제
7. outer는 삭제 되었지만 inner의 LexicalEnvironment(outerEnvironmentReference)에서 a 값을 참조
    - 가비지 컬렉터에서 변수 a를 수집하지 않음

![image](https://github.com/user-attachments/assets/ba100831-2527-4dd8-ae17-4516e19b413b)

8. inner 컨텍스트 push
9. inner 컨텍스트 실행

![image](https://github.com/user-attachments/assets/ee1afbdc-52ec-4960-9f2d-bfe4e31d4e95)

10. inner 삭제

<h2>클로저의 정의</h2>

- 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상
- 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수

<h2>클로저와 메모리 관리</h2>

- 위에서 변수 a는 가비지 컬렉터에 수집되지 않음
- 이는 곧 '메모리 누수'로 이어질 수 있음
- 그렇다면 이를 관리하는 방법은?
   - 식별자에 참조형이 아닌 기본형 데이터를 할당
   - 보통 null이나 undefined

```js
const outer = function () {
  let a = 1;
  const inner = function () {
    return ++a;
  };
  
  return inner;
};

const out = outer();

console.info(out()); // 2
console.info(out()); // 3
outer = null;
```

<h2>클로저의 활용</h2>

- 상태(state)가 의도치 않게 변경되지 않도록 안전하게 은닉한다
- 특정 함수에게만 상태 변경을 허용하여 안전하게 변경하고 유지한다

**예제1**
```javascript
// 카운트 상태 변경 함수 #1
let num = 0;

const increase = function () {
    return ++num;
};

console.log(increase());
// num = 100; // 치명적인 단점이 있다
console.log(increase());
console.log(increase());
```
- 카운트 상태(num 변수의 값)는 increase 함수만이 변경할 수 있어야 한다
- 전역변수인 num이 문제이다

**예제2**
```javascript
// 카운트 상태 변경 함수 #2
const increase = function () {
  let num = 0;
  
  return ++num;
};

// 이전 상태값을 유지 못함
console.log(increase()); //1
console.log(increase()); //1
console.log(increase()); //1
```
- 의도치 않은 변경은 방지했다
- 그러나 increase()가 호출될 때마다 num이 초기화된다

**예제3**
```javascript
// 카운트 상태 변경 함수 #3
const increase = (function () {
  let num = 0;
  
  // 클로저
  return function () {
    return ++num;
  };
})();

// 이전 상태값을 유지
console.log(increase()); //1
console.log(increase()); //2
console.log(increase()); //3
```
 - 의도한 대로 동작한다
 
**예제4 (decrease 추가)**
```javascript
// 카운트 상태 변경 함수 #4
// 클로저 카운트 기능 확장(값 감소 기능 추가)
const counter = (function () {
  //카운트 상태 변수
  let num = 0;

  // 클로저인 메서드(increase, decrease)를 갖는 객체를 반환한다
  // property는 public -> 은닉되지 않는다
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return num > 0 ? --num : 0;
    },
  };
})();

console.log(counter.increase()); // 1
console.log(counter.increase()); // 2

console.log(counter.decrease()); // 1
console.log(counter.decrease()); // 0
```
**예제5**
```javascript
// 생성자 함수
function Person(name, age) {
  this.name = name; //public
  let _age = age; //private

  // 인스턴스 메서드
  // 따라서, Person 객체가 생성될 때 마다 중복 생성됨
  // : 해결방법 -> prototype
  this.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
  };
}

const me = new Person("Choi", 33);
me.sayHi(); // Hi!, My name is Choi. I am 33.
console.log(me.name); // Choi
console.log(me._age); // undefined

const you = new Person("Lee", 30);
you.sayHi(); // Hi! My name is Lee. I am 30.
console.log(you.name); // Lee
console.log(you.age); // undefined
```
- **캡슐화**
- `프로퍼티`와 `메서드`를 하나로 묶는 것
- 목적
  - 객체의 상태 변경을 방지함으로써 정보 보호
  - 객체 간의 의존성(결합도 - coupling)을 낮춤
